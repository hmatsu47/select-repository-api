// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// コンテナイメージ一覧の取得
	// (GET /images/{repository_name})
	GetImages(c *gin.Context, repositoryName RepositoryName)
	// リポジトリ一覧の取得
	// (GET /repositories)
	GetRepositories(c *gin.Context)
	// リリース設定の取得
	// (GET /setting)
	GetSetting(c *gin.Context)
	// リリース設定の生成・更新
	// (POST /setting)
	PostSetting(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(c *gin.Context)

// GetImages operation middleware
func (siw *ServerInterfaceWrapper) GetImages(c *gin.Context) {

	var err error

	// ------------- Path parameter "repository_name" -------------
	var repositoryName RepositoryName

	err = runtime.BindStyledParameter("simple", false, "repository_name", c.Param("repository_name"), &repositoryName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter repository_name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetImages(c, repositoryName)
}

// GetRepositories operation middleware
func (siw *ServerInterfaceWrapper) GetRepositories(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetRepositories(c)
}

// GetSetting operation middleware
func (siw *ServerInterfaceWrapper) GetSetting(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetSetting(c)
}

// PostSetting operation middleware
func (siw *ServerInterfaceWrapper) PostSetting(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.PostSetting(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL     string
	Middlewares []MiddlewareFunc
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router *gin.Engine, si ServerInterface) *gin.Engine {
	return RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router *gin.Engine, si ServerInterface, options GinServerOptions) *gin.Engine {
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	router.GET(options.BaseURL+"/images/:repository_name", wrapper.GetImages)

	router.GET(options.BaseURL+"/repositories", wrapper.GetRepositories)

	router.GET(options.BaseURL+"/setting", wrapper.GetSetting)

	router.POST(options.BaseURL+"/setting", wrapper.PostSetting)

	return router
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/6xXXY/cNBT9K+jCY3YzUCqWPAHVClZQqGZ5q0YrT8abuIpjYzvtDqtIdCJBVQnRh6pI",
	"QEF8CFYLFKTysBWIP2N2W/4FspNJMhmnM6z6NvHH9TnH9x7fOYSQUc5SnCoJwSFwJBDFCgv7JTBnkigm",
	"pnspotgMTbAMBeGKsBQC0MWxLu7r2Ykubuni+PTOp+ABMTMcqRg8KLctBfJA4A8yIvAEAiUy7IEMY0yR",
	"OUFNudkilSBpBHmel4uxVG+wCcElTCbVLlaKpNGwnDOjIUsVTu1PxHlCQmRg+gc0MUPNCS8IvA8BPO83",
	"3P1yVvqyjArmWJolinAklL/PBN2YIIUWA1VQ2fgaDlUJ1aHPsS7+0rNHT45+PX3whfmc/aZnR3r2yIr2",
	"lS4+0bPvoeQpOUtlyTHCaoeiCA+rwacwvCbNaetSJCaqE+3soS4e6uJjXdzWsx908a1FfqKLXyza+2bW",
	"/KgxewblsL7cZw61yZtedZvsWwGzzpeVGM+ZMGvdfh/EfF4C9u7LK1out94L+s7EKX4GD7hgHAtVFcqE",
	"RFVxdMrKA57JGE/2kHvWUfpLayT5sD2RZnSMhZlQKCppKEylc2s1gIRAU/OdCeKq/bZPXLWLquDV4Z7D",
	"WSrKbYIjDxRRiQldKut1SteDgw2SKixSlECwjxKJzZBUjCckiq1EZAIBbA1oGEdyGr2abt2oANYpusoe",
	"+6+pV+K1dKmIm7Utpi1g56aLLsaUji+KCbsx3iqTtEp3N9dOsvfRtZew5+bmAZF7AicYScOunh8zlmCU",
	"lrlpZ92p29GmOWph3+IpLdXm/FyS4QNEeWIp5A4JrQOQdJ/NrQWFFiCmiCQQQEyRktnLr7wWmYHNkNHm",
	"gXyLCDZFMnvuslkTE4nshdptSnEZ+H5EVJyNzTZ/HgmWLGf70rCTdP/ePDm7/fXju0evX9kBDxIS4sr9",
	"qqMv77y/zlm+xAkO1UaTVhuIc3+csLFPkVRY+O/sXNp+d3fb1nctZ2cTeHAdC1mifXFzYBYzjlPECQRw",
	"YXOwOTDpglRsM6V8rKR/2KnzvHoh1/fIf04+evLjT/rmg9PP7p3+/TnYY4U1/B2T6m9Wz62Ezjv80mDQ",
	"9wbU6/ylx9rWSkYpMr7wP0CV1lnlLYyMT7dasqtuHM0Sv+uHuQnRjJK6t1jpVmsINmyHPadsju6ho90q",
	"WHPJWkk2MiH8llf1E160rKex3a2t4VxEu/2Hg2UvljnFOaORy3482xavSfPx3W/Obt3RxZ9nX/5xdu/3",
	"Jb5Xmg4b2g34tJ9rq0f3HQ167tZtEet7b6+jyzL4JYHy8rES1+d10xhc4PsJC1ESM6mCC4PBAPJRHWFd",
	"O2msu2qnvRXl5Poz1LdrgW+zsW41R/l/AQAA///6zsaYuA0AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
